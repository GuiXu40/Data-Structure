<p id="title"></p>

# :dart:线性表

<a href="#p1">:spades:线性表的类型定义</a><br>
<a href="#p2">:spades:线性表的顺序表示和实现</a><br>
<a href="#p3">:spades:线性表的链式表示和实现</a><br>
<a href="#p4">:spades:一元多项式的表示及相加</a><br>

<p id="p1"></p>

## :hearts:线性表的类型定义
<a href="#title">:registered:回到目录</a>
线性表(linear_list):是n个数据元素的有限集合..在复杂的线性表中,一个数据元素由若干个数据项(item)组成(是一个相当灵活的数据结构,他的长度可根剧需要增长或缩短,操作性很强).<br>
抽象数据类型定义如下(之后的算法都建立在此之上):
```伪代码
ADT list{
  数据对象:D={ai | ai属于ElemSet,i=1,2,...n>=0}
  数据关系:R1={<a i-1,ai>| ai-1 ai属于D,i=2...,n}
  基本操作:
    InitList(&L)
      操作结果:构造一个空的线性表L.
    DestroyList(&L)
      初始条件:线性表L已存在
      操作结果:销毁线性表
    ClearList(&L)
      初始条件:线性表L已存在
      操作结果:将线性表置为空表
    ListEmpty(L)
      初始条件:线性表L已存在
      操作结果:若L为空表返回TRUE,否则返回FALSE
    ListLength(L)
      初始条件:线性表L已存在
      操作结果:返回L中的元素个数
    GitElem(L,i,&e)
      初始条件:线性表L已存在
      操作结果:用e返回L中第i个数据元素的值
    LocateElem(L,e,compare())
      初始条件:线性表L已存在,compare是数据元素的判定函数
      操作结果:返回L中第一个与e满足关系compare()的数据元素的位序,若不存在,则返回0
    PriorElem(L,cur_e,&pre_e)
      初始条件:线性表L已存在
      操作结果:若cur_e是L的数据元素,且不是第一个,则用pre_e返回他的前驱,否则无定义
    NextElem(L,cur_e,&next_e)
      初始条件:线性表L已存在
      操作结果:若cur_e是L的数据元素,且不是最后一个,则用next_e返回他的后继,否则无定义
    ListInsert(&L,i,e)
      初始条件:线性表L已存在
      操作结果:在L中第i个位置前插入新的数据元素e,L的长度加1
    ListDelete(&L,i,&e)
      初始条件:线性表L已存在
      操作结果:删除L的第i个元素.并用e返回其值,L的长度减1
    ListTraverse(L,visit())
      初始条件:线性表L已存在
      操作结果:依次对L中的每个元素调用visit().一旦visit()失败,则操作失败
}ADT List
```
还有一些复杂的操作:<br>
+ 例一:两个线性表A,B,求一个新的集合A是A与B的并集
```伪代码
void union(List &La,List Lb){
    //将所有在线性表Lb中但不在La中的数据元素插入到La中
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    for(i=0;i<Lb_len;i++){
        GetElem(Lb,i,&e);
        if(!LocateELem(La,e,equal))
            Listinsert(La,++La_len,e);//La中不存在和e相同的数据元素,则插入之
    }
}//union

```
+ 已知LA和LB中的数据元素按照非递减的方式排列,将其合并成一个线性表LC,且LC中的数据元素也按照非递减有序排列.<br>
比如:LA=(3,5,8,11)  LB=(2,6,8,9,11,15,20)  ==>Lc=(2,3,5,6,8,8,9,11,11,15,,20)
```伪代码
void MergeList(List La,List Lb,List &Lc){
  //已知线性表La和Lb中的数据按值非递减排序
  InitList(Lc);
  i=j=1;k=0;
  La_len=ListLength(La);Lb_len=ListLength(Lb);
  while((i<La_len) && (i<Lb_len)){
      GetElem(La,i,ai);GetElem(Lb,j,bj);
      if(ai<bj){
          ListInsert(Lc,++k,ai);
          ++i;
      }else{
          ListInsert(Lc,++k,bj);
          ++j;
      }
  }
  //下面的代码的意思是什么?
  while(i<La_len){
      GetElem(La,i++,ai);
      ListInsert(Lc,++k;ai);
  }
  while(j<=Lb_len){
      GetElem(Lb,j++,bj);
      ListInsert(Lc,++k;bj);
  }
}
```
<p id="p2"></p>

## :hearts:线性表的顺序表示和实现
<a href="#title">:registered:回到目录</a>
线性表的顺序表示指用一组地址连续的储存单元依次储存线性表的数据元素(C语言中的数组  但由于线性表的长度可变,就用动态分配的一维数组,描述如下)
```伪代码
------------线性表的动态分配顺序储存结构-----------------
#define LIST_INIT_SIZE 100  //线性储存空间的初始分配量
#define LISTINCREMENT 10    //线性储存空间的分配增量
typedef struct{
    ElemType *elem;  //储存空间基址
    int length ;   //当前长度
    int listsize;  //当前分配的储存容量(以sizeof(ElemType)为单位)
}SqList;
```
```伪代码
Status InitList_Sq(SqList &L){
    
}
```
<p id="p3"></p>

## :hearts:线性表的链式表示和实现
<a href="#title">:registered:回到目录</a>
### :diamonds:
### :diamonds:
### :diamonds:
<p id="p4"></p>

## :hearts:一元多项式的表示及相加
<a href="#title">:registered:回到目录</a>
